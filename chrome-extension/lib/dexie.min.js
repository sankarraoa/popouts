// Simple IndexedDB wrapper (Dexie.js compatible API)
// This is a minimal implementation that works without external dependencies

(function() {
  'use strict';

  class Dexie {
    constructor(dbName) {
      this.dbName = dbName;
      this.db = null;
      this.schema = null;
      this.initPromise = null;
      this.version = (v) => ({
        stores: (schema) => {
          this.schema = schema;
          this.initPromise = this.initDB();
        }
      });
    }

    async initDB() {
      if (this.db) {
        // Ensure store properties are set up
        if (this.schema) {
          this.setupStoreProperties();
        }
        return Promise.resolve();
      }
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(this.dbName, 1);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
          this.db = request.result;
          // Set up store properties after DB is ready
          if (this.schema) {
            this.setupStoreProperties();
          }
          resolve();
        };
        request.onupgradeneeded = (e) => {
          this.db = e.target.result;
          this.createStores();
        };
      });
    }
    
    setupStoreProperties() {
      if (!this.schema) return;
      const self = this;
      Object.keys(this.schema).forEach(storeName => {
        if (!this[storeName]) {
          // Create a property that accesses the store proxy
          Object.defineProperty(this, storeName, {
            get: function() {
              return self.store[storeName];
            },
            enumerable: true,
            configurable: true
          });
        }
      });
    }

    async ensureReady() {
      if (this.initPromise) {
        await this.initPromise;
      }
      if (!this.db) {
        await this.initDB();
      }
      // Ensure store properties are set up
      if (this.schema) {
        this.setupStoreProperties();
      }
    }

    createStores() {
      if (!this.schema || !this.db) return;
      const self = this;
      Object.keys(this.schema).forEach(storeName => {
        if (!this.db.objectStoreNames.contains(storeName)) {
          const keyPath = 'id';
          const store = this.db.createObjectStore(storeName, { keyPath, autoIncrement: true });
          // Parse index definitions from schema (e.g., '++id, name, type')
          const indexDef = this.schema[storeName];
          if (indexDef) {
            const indexes = indexDef.split(',').map(s => s.trim());
            indexes.forEach(index => {
              if (index && index !== '++id' && !index.startsWith('++')) {
                try {
                  store.createIndex(index, index);
                } catch(e) {
                  // Index might already exist
                }
              }
            });
          }
        }
      });
      // Set up store properties after creating stores
      this.setupStoreProperties();
    }

    get store() {
      const self = this;
      return new Proxy({}, {
        get(target, storeName) {
          if (!self.schema || !self.schema[storeName]) return undefined;
          return {
            add: async (data) => {
              await self.ensureReady();
              return new Promise((resolve, reject) => {
                const tx = self.db.transaction([storeName], 'readwrite');
                const store = tx.objectStore(storeName);
                const request = store.add({ ...data, id: data.id || Date.now() });
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
              });
            },
            get: async (id) => {
              await self.ensureReady();
              return new Promise((resolve, reject) => {
                const tx = self.db.transaction([storeName], 'readonly');
                const store = tx.objectStore(storeName);
                const request = store.get(id);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
              });
            },
            toArray: async () => {
              await self.ensureReady();
              return new Promise((resolve, reject) => {
                const tx = self.db.transaction([storeName], 'readonly');
                const store = tx.objectStore(storeName);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result || []);
                request.onerror = () => reject(request.error);
              });
            },
            where: (field) => ({
              equals: (value) => ({
                toArray: async () => {
                  await self.ensureReady();
                  return new Promise((resolve, reject) => {
                    const tx = self.db.transaction([storeName], 'readonly');
                    const store = tx.objectStore(storeName);
                    const request = store.getAll();
                    request.onsuccess = () => {
                      const results = (request.result || []).filter(item => item[field] === value);
                      resolve(results);
                    };
                    request.onerror = () => reject(request.error);
                  });
                },
                sortBy: async (field) => {
                  await self.ensureReady();
                  return new Promise((resolve, reject) => {
                    const tx = self.db.transaction([storeName], 'readonly');
                    const store = tx.objectStore(storeName);
                    const request = store.getAll();
                    request.onsuccess = () => {
                      const results = (request.result || []).filter(item => item[field] === value);
                      results.sort((a, b) => {
                        const aVal = a[field];
                        const bVal = b[field];
                        if (aVal < bVal) return -1;
                        if (aVal > bVal) return 1;
                        return 0;
                      });
                      resolve(results);
                    };
                    request.onerror = () => reject(request.error);
                  });
                },
                delete: async () => {
                  await self.ensureReady();
                  return new Promise((resolve, reject) => {
                    const tx = self.db.transaction([storeName], 'readwrite');
                    const store = tx.objectStore(storeName);
                    const request = store.getAll();
                    request.onsuccess = () => {
                      const items = request.result || [];
                      const deletePromises = items
                        .filter(item => item[field] === value)
                        .map(item => {
                          return new Promise((res, rej) => {
                            const delReq = store.delete(item.id);
                            delReq.onsuccess = () => res();
                            delReq.onerror = () => rej(delReq.error);
                          });
                        });
                      Promise.all(deletePromises).then(() => resolve()).catch(reject);
                    };
                    request.onerror = () => reject(request.error);
                  });
                }
              })
            }),
            update: async (id, updates) => {
              await self.ensureReady();
              return new Promise((resolve, reject) => {
                const tx = self.db.transaction([storeName], 'readwrite');
                const store = tx.objectStore(storeName);
                const getReq = store.get(id);
                getReq.onsuccess = () => {
                  const item = getReq.result;
                  if (item) {
                    Object.assign(item, updates);
                    const putReq = store.put(item);
                    putReq.onsuccess = () => resolve();
                    putReq.onerror = () => reject(putReq.error);
                  } else {
                    resolve();
                  }
                };
                getReq.onerror = () => reject(getReq.error);
              });
            },
            delete: async (id) => {
              await self.ensureReady();
              return new Promise((resolve, reject) => {
                const tx = self.db.transaction([storeName], 'readwrite');
                const store = tx.objectStore(storeName);
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
              });
            }
          };
        }
      });
    }
  }

  // Make Dexie available globally
  if (typeof window !== 'undefined') {
    window.Dexie = Dexie;
  }
  if (typeof global !== 'undefined') {
    global.Dexie = Dexie;
  }
  if (typeof self !== 'undefined') {
    self.Dexie = Dexie;
  }
})();
